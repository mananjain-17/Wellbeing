/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for most data,
 *              with specific handling for peer-to-peer messages. It prioritizes
 *              authorization independence by denormalizing user IDs onto subcollection
 *              documents, avoiding costly `get()` operations in the rules.
 *
 * Data Structure:
 * - /users/{userId}: Root-level user profiles, accessible only by the owning user.
 * - /users/{userId}/{subcollection}/{docId}: User-owned data like mood entries, vents,
 *   journal entries, contacts, and stress check-ins, accessible only by the owning user.
 * - /peerPulseMessages_sent/{messageId}: Public collection for sent messages.
 * - /peerPulseMessages_received/{messageId}: Public collection for received messages.
 *
 * Key Security Decisions:
 * - No user listing is allowed.
 * - All write operations (create, update, delete) are strictly controlled by ownership.
 * - The 'userId' is denormalized onto documents in user subcollections to avoid get() calls.
 * - PeerPulse messages are stored in separate collections to support efficient queries
 *   and authorization based on sender/receiver IDs.
 *
 * Denormalization for Authorization:
 * - MoodEntry, Vent, JournalEntry, Contact, and StressCheckIn documents all include
 *   a 'userId' field to allow direct ownership checks without reading the parent
 *   /users/{userId} document.
 *
 * Structural Segregation:
 * - PeerPulse messages are split into separate 'sent' and 'received' collections
 *   for efficient querying and access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profile information. Only the authenticated user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create) - User with UID 'user_abc' can create their profile with user ID 'user_abc'.
     * @allow (get, update, delete) - User with UID 'user_abc' can get, update, and delete their profile with user ID 'user_abc'.
     * @deny (create) - User with UID 'user_def' cannot create a profile with user ID 'user_abc'.
     * @deny (get, update, delete) - User with UID 'user_def' cannot get, update, or delete the profile with user ID 'user_abc'.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // No user listing

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId); // Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to mood entries. Only the owning user can read/write their mood entries.
     * @path /users/{userId}/moodEntries/{moodEntryId}
     * @allow (create) - User with UID 'user_abc' can create a mood entry under /users/user_abc/moodEntries.
     * @allow (get, list, update, delete) - User with UID 'user_abc' can get, list, update, and delete their own mood entries.
     * @deny (create) - User with UID 'user_def' cannot create a mood entry under /users/user_abc/moodEntries.
     * @deny (get, list, update, delete) - User with UID 'user_def' cannot get, list, update, or delete mood entries under /users/user_abc/moodEntries.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/moodEntries/{moodEntryId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId); // Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to vents. Only the owning user can read/write their vents.
     * @path /users/{userId}/vents/{ventId}
     * @allow (create) - User with UID 'user_abc' can create a vent under /users/user_abc/vents.
     * @allow (get, list, update, delete) - User with UID 'user_abc' can get, list, update, and delete their own vents.
     * @deny (create) - User with UID 'user_def' cannot create a vent under /users/user_abc/vents.
     * @deny (get, list, update, delete) - User with UID 'user_def' cannot get, list, update, or delete vents under /users/user_abc/vents.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/vents/{ventId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId); // Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to sent PeerPulseMessages. Only the sender can create, and only the sender or receiver can read.
     * @path /peerPulseMessages_sent/{messageId}
     * @allow (create) - User with UID 'user_abc' can create a message in /peerPulseMessages_sent with senderId 'user_abc'.
     * @allow (get, list) - Any signed-in user can read a message where they are the sender or receiver.
     * @deny (update, delete) - No one can update or delete a sent message.
     * @principle Allows public read, enforces ownership for create, and prohibits updates/deletes.
     */
    match /peerPulseMessages_sent/{messageId} {
      allow get: if request.auth != null;
      allow list: if request.auth != null;

      allow create: if request.auth != null && request.resource.data.senderId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to received PeerPulseMessages. Only the receiver can read.
     * @path /peerPulseMessages_received/{messageId}
     * @allow (get, list) - Any signed-in user can read messages where they are the receiver.
     * @deny (create, update, delete) - No one can create, update, or delete a received message directly. Creation happens via the 'sent' collection.
     * @principle Allows public read, prohibits writes.
     */
    match /peerPulseMessages_received/{messageId} {
      allow get: if request.auth != null;
      allow list: if request.auth != null;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to journal entries. Only the owning user can read/write their journal entries.
     * @path /users/{userId}/journalEntries/{journalEntryId}
     * @allow (create) - User with UID 'user_abc' can create a journal entry under /users/user_abc/journalEntries.
     * @allow (get, list, update, delete) - User with UID 'user_abc' can get, list, update, and delete their own journal entries.
     * @deny (create) - User with UID 'user_def' cannot create a journal entry under /users/user_abc/journalEntries.
     * @deny (get, list, update, delete) - User with UID 'user_def' cannot get, list, update, or delete journal entries under /users/user_abc/journalEntries.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/journalEntries/{journalEntryId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId); // Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to contacts. Only the owning user can read/write their contacts.
     * @path /users/{userId}/contacts/{contactId}
     * @allow (create) - User with UID 'user_abc' can create a contact under /users/user_abc/contacts.
     * @allow (get, list, update, delete) - User with UID 'user_abc' can get, list, update, and delete their own contacts.
     * @deny (create) - User with UID 'user_def' cannot create a contact under /users/user_abc/contacts.
     * @deny (get, list, update, delete) - User with UID 'user_def' cannot get, list, update, or delete contacts under /users/user_abc/contacts.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/contacts/{contactId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId); // Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to stress check-in entries. Only the owning user can read/write their stress check-in entries.
     * @path /users/{userId}/stressCheckIns/{stressCheckInId}
     * @allow (create) - User with UID 'user_abc' can create a stress check-in under /users/user_abc/stressCheckIns.
     * @allow (get, list, update, delete) - User with UID 'user_abc' can get, list, update, and delete their own stress check-in entries.
     * @deny (create) - User with UID 'user_def' cannot create a stress check-in under /users/user_abc/stressCheckIns.
     * @deny (get, list, update, delete) - User with UID 'user_def' cannot get, list, update, or delete stress check-in entries under /users/user_abc/stressCheckIns.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/stressCheckIns/{stressCheckInId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId); // Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }
  }
}